<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avrupa Gezi Listesi</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .place-item:hover {
            background-color: #f0f9ff;
        }
        .place-item.selected-for-route {
            background-color: #dbeafe;
            border-left: 4px solid #2563eb;
        }
        .country-header {
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e5e7eb;
            font-size: 1.25rem;
            font-weight: 600;
            color: #1e3a8a;
        }
        #generateRouteBtn, #addPlaceBtn, .delete-place-btn {
            transition: background-color 0.3s ease;
        }
        .category-tag {
            display: inline-block;
            background-color: #e0e7ff;
            color: #3730a3;
            padding: 0.125rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 500;
            margin-top: 0.25rem;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .delete-place-btn {
            background-color: #fee2e2; /* red-100 */
            color: #b91c1c; /* red-700 */
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 500;
        }
        .delete-place-btn:hover {
            background-color: #fecaca; /* red-200 */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 md:p-8">

    <div class="container mx-auto max-w-7xl bg-white shadow-xl rounded-lg p-6">
        <header class="mb-8 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-sky-600">Avrupa Gezi Rotam</h1>
            <p class="text-gray-600 mt-2">Gezilecek yerleri işaretle, filtrele, sil ve haritada gör! Rota oluşturmak için yerlere tıklayarak seçin veya yeni yer ekleyin.</p>
            <p id="authStatus" class="text-xs text-gray-500 mt-1">Kimlik durumu: Kontrol ediliyor...</p>
             <p id="userIdDisplay" class="text-xs text-gray-400 mt-1"></p>
        </header>

        <div class="flex flex-col md:flex-row gap-6">
            <div class="w-full md:w-3/5 lg:w-2/3 pr-0 md:pr-4">
                <div class="mb-6 p-4 border border-gray-200 rounded-lg bg-slate-50">
                    <h3 class="text-lg font-semibold text-gray-700 mb-2">Yeni Yer Ekle</h3>
                    <div class="flex flex-col sm:flex-row gap-2">
                        <input type="text" id="newPlaceNameInput" placeholder="Örn: Etretat Kayalıkları" class="flex-grow p-2 border border-gray-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                        <button id="addPlaceBtn" class="bg-emerald-500 hover:bg-emerald-600 text-white font-semibold py-2 px-4 rounded-md shadow-md flex items-center justify-center" disabled>
                            <span id="addPlaceBtnText">Yer Ekle</span>
                            <div id="addPlaceLoader" class="loader hidden"></div>
                        </button>
                    </div>
                    <div id="addPlaceMessage" class="text-sm mt-2"></div>
                </div>

                <div class="mb-6 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
                    <div>
                        <h2 class="text-2xl font-semibold text-gray-700">Gezilecek Yerler</h2>
                        <p class="text-sm text-gray-500">Rota oluşturmak için listeden yerlere tıklayın.</p>
                    </div>
                    <div>
                        <label for="filterVisited" class="mr-2 text-gray-600">Filtrele (Ziyaret):</label>
                        <select id="filterVisited" class="p-2 border border-gray-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                            <option value="all">Tümü</option>
                            <option value="notvisited" selected>Gezilmedi</option>
                            <option value="visited">Gezildi</option>
                        </select>
                    </div>
                </div>
                 <div class="mb-4">
                    <button id="generateRouteBtn" class="w-full sm:w-auto bg-sky-600 hover:bg-sky-700 text-white font-semibold py-2 px-4 rounded-md shadow-md disabled:opacity-50" disabled>
                        Seçilenlerle Rota Oluştur
                    </button>
                </div>
                <div id="routeLinkContainer" class="mb-4 text-sm"></div>
                <div id="placesList" class="space-y-1 max-h-[40vh] md:max-h-[50vh] overflow-y-auto custom-scrollbar pr-2">
                    <p class="text-gray-500 italic p-4">Yer listesi yükleniyor veya Firebase ile bağlantı bekleniyor...</p>
                </div>
            </div>

            <div class="w-full md:w-2/5 lg:w-1/3 mt-6 md:mt-0">
                <h2 id="mapTitle" class="text-2xl font-semibold text-gray-700 mb-2">Harita</h2>
                <p id="mapLocationName" class="text-sm text-gray-500 mb-4 h-5"></p>
                <div class="aspect-w-16 aspect-h-9 md:aspect-h-12 lg:aspect-h-10 rounded-lg overflow-hidden shadow-md">
                     <iframe id="mapFrame"
                        class="w-full h-full border-0"
                        loading="lazy"
                        allowfullscreen
                        referrerpolicy="no-referrer-when-downgrade"
                        src="https://maps.google.com/maps?q=Avrupa&t=&z=4&ie=UTF8&iwloc=&output=embed">
                    </iframe>
                </div>
                <p class="mt-4 text-xs text-gray-500">
                    Haritada bir yerin işaretlenmesi, o yerin genel konumunu gösterir. Rota oluşturma özelliği, seçilen yerleri Google Haritalar'a gönderir. Yeni yer ekleme özelliği, bilgileri otomatik olarak bulmaya çalışır; sonuçlar API'lerin yeteneklerine bağlıdır. Verileriniz Firebase'de saklanır.
                </p>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase SDK imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js"; // signInWithCustomToken kaldırıldı, Canvas dışı ortamda genellikle kullanılmaz.
        import { getFirestore, collection, doc, addDoc, getDocs, deleteDoc, updateDoc, onSnapshot, query, orderBy, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ----- KENDİ FIREBASE PROJE YAPILANDIRMANIZI BURAYA EKLEYİN! -----
        // For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyB6bIJOkooeRSKWtb09zdNmMIjHDbXCzYA",
  authDomain: "rotambenim.firebaseapp.com",
  projectId: "rotambenim",
  storageBucket: "rotambenim.firebasestorage.app",
  messagingSenderId: "374285362920",
  appId: "1:374285362920:web:b4058cf4a93e7337168b5d",
  measurementId: "G-0QVZ4LDYPJ"
};
        // --------------------------------------------------------------------
        
        // Canvas'a özel __app_id yerine, kendi projenizde bir tanımlayıcı kullanabilirsiniz
        // Veya Firebase Hosting kullanıyorsanız, projectId genellikle yeterlidir.
        // Bu örnekte appId'yi Firebase yapılandırmasından gelen appId olarak kullanabiliriz.
        const appId = firebaseConfig.appId || 'default-app-id';


        let app;
        let auth;
        let db;
        let userId;
        let placesCollectionRef; 
        let unsubscribePlaces = null; 

        const initialPlacesData = [
            { userGivenId: 'fr1', country: "FRANSA", name: "Eyfel Kulesi", city: "Paris", description: "Paris'in dünyaca ünlü demir kulesi...", category: "İkonik Yapı / Mimari", visited: false, mapQuery: "Eyfel Kulesi, Paris, Fransa", selectedForRoute: false },
            { userGivenId: 'fr2', country: "FRANSA", name: "Louvre Müzesi", city: "Paris", description: "Mona Lisa ve Venus de Milo gibi dünyaca ünlü başyapıtlara ev sahipliği yapan...", category: "Sanat ve Tarih / Müze", visited: false, mapQuery: "Louvre Müzesi, Paris, Fransa", selectedForRoute: false },
            { userGivenId: 'it1', country: "İTALYA", name: "Kolezyum ve Roma Forumu", city: "Roma", description: "Antik Roma'nın ihtişamını yansıtan...", category: "Antik Kalıntı / Tarihi Alan", visited: false, mapQuery: "Kolezyum, Roma, İtalya", selectedForRoute: false },
        ];
        let placesData = []; 

        const placesListElement = document.getElementById('placesList');
        const filterElement = document.getElementById('filterVisited');
        const mapFrameElement = document.getElementById('mapFrame');
        const mapLocationNameElement = document.getElementById('mapLocationName');
        const generateRouteBtn = document.getElementById('generateRouteBtn');
        const routeLinkContainer = document.getElementById('routeLinkContainer');
        const newPlaceNameInput = document.getElementById('newPlaceNameInput');
        const addPlaceBtn = document.getElementById('addPlaceBtn');
        const addPlaceBtnText = document.getElementById('addPlaceBtnText');
        const addPlaceLoader = document.getElementById('addPlaceLoader');
        const addPlaceMessage = document.getElementById('addPlaceMessage');
        const authStatusElement = document.getElementById('authStatus');
        const userIdDisplayElement = document.getElementById('userIdDisplay');

        let selectedRouteOrder = []; 

        async function initializeFirebase() {
            if (!firebaseConfig || !firebaseConfig.apiKey || firebaseConfig.apiKey === "SENIN_API_ANAHTARIN") { // Daha iyi bir kontrol
                authStatusElement.textContent = "Firebase yapılandırması eksik veya hatalı. Lütfen JavaScript kodundaki firebaseConfig nesnesini kendi proje bilgilerinizle güncelleyin.";
                console.error("Firebase config is missing or incomplete. Please update it in your JavaScript code.");
                addPlaceBtn.disabled = true; 
                return;
            }
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                authStatusElement.textContent = "Firebase başlatıldı. Kimlik doğrulanıyor...";

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        authStatusElement.textContent = `Kimlik doğrulandı (Anonim Kullanıcı).`;
                        userIdDisplayElement.textContent = `Kullanıcı ID: ${userId.substring(0,12)}...`; 
                        // Firestore collection path'ini userId ile oluştur
                        placesCollectionRef = collection(db, `users/${userId}/europeTravelPlaces`);
                        addPlaceBtn.disabled = false; 
                        loadAndListenPlaces();
                    } else {
                        authStatusElement.textContent = "Anonim oturum açılıyor...";
                        try {
                            await signInAnonymously(auth);
                            // onAuthStateChanged tekrar tetiklenecek ve user dolu gelecek.
                        } catch (error) {
                            console.error("Anonim oturum açma hatası:", error);
                            authStatusElement.textContent = "Oturum açılamadı: " + error.message;
                            addPlaceBtn.disabled = true;
                        }
                    }
                });
            } catch (error) {
                console.error("Firebase başlatma hatası:", error);
                authStatusElement.textContent = "Firebase başlatılamadı: " + error.message;
                addPlaceBtn.disabled = true;
            }
        }
        
        async function loadAndListenPlaces() {
            if (!placesCollectionRef) return;
            authStatusElement.textContent = "Yer listesi Firestore'dan yükleniyor...";

            if (unsubscribePlaces) unsubscribePlaces(); 

            // İlk veri ekleme kontrolü (daha basit bir yaklaşımla)
            const initialSeedFlagDocRef = doc(db, `users/${userId}/europeTravelFlags`, "initialSeedDone");
            const seedFlagSnap = await getDoc(initialSeedFlagDocRef);

            if (!seedFlagSnap.exists()) {
                authStatusElement.textContent = "İlk veriler Firestore'a ekleniyor...";
                let initialDataAdded = false;
                for (const place of initialPlacesData) {
                    // Firestore'un kendi ID'lerini kullanmak için addDoc kullanalım
                    // veya userGivenId'yi belge ID'si olarak kullanabiliriz eğer benzersizse.
                    // Bu örnekte, Firestore'un ID üretmesine izin verelim.
                    try {
                        const docRefWithAutoId = doc(placesCollectionRef); // Yeni boş döküman referansı al
                        await setDoc(docRefWithAutoId, { ...place, id: docRefWithAutoId.id }); // Kendi ID'sini de ekleyelim
                        initialDataAdded = true;
                    } catch (e) { console.error("İlk veri ekleme hatası:", e); }
                }
                if (initialDataAdded) {
                    await setDoc(initialSeedFlagDocRef, { seeded: true, seededAt: new Date().toISOString() });
                }
                authStatusElement.textContent = "İlk veriler eklendi (veya zaten vardı). Liste dinleniyor...";
            }


            unsubscribePlaces = onSnapshot(query(placesCollectionRef, orderBy("country"), orderBy("name")), (snapshot) => {
                placesData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderPlacesList();
                updateGenerateRouteButtonState();
                // authStatusElement.textContent = `Yer listesi güncel (${placesData.length} yer).`; // Çok sık güncellenmemesi için bunu kapatabiliriz
            }, (error) => {
                console.error("Firestore'dan yerleri dinleme hatası: ", error);
                authStatusElement.textContent = "Yer listesi yüklenemedi: " + error.message;
            });
        }

        function renderPlacesList() {
            const filterValue = filterElement.value;
            placesListElement.innerHTML = ''; 
            let currentCountry = ""; 

            const filteredPlaces = placesData.filter(place => {
                if (filterValue === 'all') return true;
                if (filterValue === 'visited') return place.visited;
                if (filterValue === 'notvisited') return !place.visited;
                return true;
            });

            if (filteredPlaces.length === 0) {
                placesListElement.innerHTML = '<p class="text-gray-500 italic p-4">Bu filtreye uygun yer bulunamadı veya liste boş.</p>';
                return;
            }
            
            filteredPlaces.forEach(place => {
                if (place.country !== currentCountry) {
                    currentCountry = place.country || "Diğer";
                    const countryHeader = document.createElement('h3');
                    countryHeader.className = 'country-header';
                    countryHeader.textContent = currentCountry;
                    placesListElement.appendChild(countryHeader);
                }

                const listItem = document.createElement('div');
                listItem.className = `place-item p-4 border border-gray-200 rounded-lg shadow-sm cursor-pointer transition-all duration-150 ease-in-out mt-2 ${place.selectedForRoute ? 'selected-for-route' : ''}`;
                listItem.setAttribute('data-id', place.id); 
                
                listItem.innerHTML = `
                    <div class="flex items-start justify-between">
                        <div class="flex-grow">
                            <h4 class="text-lg font-semibold text-sky-700">${place.name}</h4>
                            <p class="text-sm text-gray-500">${place.city ? place.city + ', ' : ''}${place.country ? place.country.replace(' (BK)', '') : 'Bilinmeyen Ülke'}</p>
                            ${place.category ? `<span class="category-tag">${place.category}</span>` : '<span class="category-tag">Bilinmiyor</span>'}
                            <p class="text-sm text-gray-600 mt-1">${place.description || 'Açıklama bulunamadı.'}</p>
                        </div>
                        <div class="ml-4 flex-shrink-0 flex flex-col items-center space-y-2">
                            <div>
                                <input type="checkbox" id="visited-${place.id}" data-id="${place.id}" class="h-5 w-5 text-sky-600 border-gray-300 rounded focus:ring-sky-500" ${place.visited ? 'checked' : ''}>
                                <label for="visited-${place.id}" class="text-xs text-gray-500 ml-1">${place.visited ? 'Gezildi' : 'Gezilmedi'}</label>
                            </div>
                            <button class="delete-place-btn" data-id="${place.id}">Sil</button>
                        </div>
                    </div>
                `;

                listItem.addEventListener('click', async (event) => {
                    if (event.target.classList.contains('delete-place-btn') || event.target.id.startsWith('visited-') || (event.target.tagName === 'LABEL' && event.target.htmlFor.startsWith('visited-'))) {
                        return;
                    }
                    const placeId = place.id;
                    const targetPlaceInLocalData = placesData.find(p => p.id === placeId); // Önce lokal veride bul
                    if (targetPlaceInLocalData) {
                        const newSelectedState = !targetPlaceInLocalData.selectedForRoute;
                         if (placesCollectionRef) { 
                            const placeDocRef = doc(db, `users/${userId}/europeTravelPlaces`, placeId);
                            try {
                                await updateDoc(placeDocRef, { selectedForRoute: newSelectedState });
                                // Lokal veriyi hemen güncellemek yerine onSnapshot'a güvenebiliriz
                                // targetPlaceInLocalData.selectedForRoute = newSelectedState; // Veya hemen güncelle
                                if (newSelectedState) {
                                    if (!selectedRouteOrder.includes(targetPlaceInLocalData.id)) selectedRouteOrder.push(targetPlaceInLocalData.id);
                                } else {
                                    selectedRouteOrder = selectedRouteOrder.filter(id => id !== targetPlaceInLocalData.id);
                                }
                                updateMap(targetPlaceInLocalData); 
                                // renderPlacesList(); // onSnapshot halledecek
                                updateGenerateRouteButtonState();
                            } catch (e) { console.error("Rota seçimi güncelleme hatası:", e); }
                        }
                    }
                });

                const visitedCheckbox = listItem.querySelector(`#visited-${place.id}`);
                visitedCheckbox.addEventListener('change', async (event) => {
                    const placeId = event.target.dataset.id;
                    const isChecked = event.target.checked;
                    if (placesCollectionRef) {
                        const placeDocRef = doc(db, `users/${userId}/europeTravelPlaces`, placeId);
                        try {
                            await updateDoc(placeDocRef, { visited: isChecked });
                        } catch (e) { console.error("Ziyaret durumu güncelleme hatası:", e); }
                        // onSnapshot halledecek
                    }
                });

                const deleteButton = listItem.querySelector('.delete-place-btn');
                deleteButton.addEventListener('click', async () => {
                    const placeIdToDelete = deleteButton.dataset.id;
                    const placeNameToDelete = placesData.find(p => p.id === placeIdToDelete)?.name || "bu yer";
                     if (confirm(`'${placeNameToDelete}' adlı yeri silmek istediğinizden emin misiniz?`)) {
                        if (placesCollectionRef) {
                            const placeDocRef = doc(db, `users/${userId}/europeTravelPlaces`, placeIdToDelete);
                            try {
                                await deleteDoc(placeDocRef);
                                selectedRouteOrder = selectedRouteOrder.filter(id => id !== placeIdToDelete);
                                // onSnapshot halledecek
                            } catch (e) { console.error("Yer silme hatası:", e); }
                        }
                    }
                });
                placesListElement.appendChild(listItem);
            });
        }

        function updateMap(place) {
            if (place && place.mapQuery) {
                const encodedQuery = encodeURIComponent(place.mapQuery);
                let zoomLevel = 10; 
                if (place.name.toLowerCase().includes("bölgesi") || place.name.toLowerCase().includes("sahili") || place.name.toLowerCase().includes("gölü") || place.name.toLowerCase().includes("dağları")) {
                    zoomLevel = 8;
                }
                if (place.country && place.mapQuery === place.country) { 
                    zoomLevel = 5;
                }
                mapFrameElement.src = `https://maps.google.com/maps?q=${encodedQuery}&t=&z=${zoomLevel}&ie=UTF8&iwloc=&output=embed`;
                mapLocationNameElement.textContent = `${place.name}, ${place.country ? place.country.replace(' (BK)', '') : ''}`;
            } else {
                mapFrameElement.src = `https://maps.google.com/maps?q=Avrupa&t=&z=4&ie=UTF8&iwloc=&output=embed`;
                mapLocationNameElement.textContent = "Avrupa Genel Görünüm";
            }
        }
        
        function updateGenerateRouteButtonState() {
            const selectedPlacesForRoute = placesData.filter(p => p.selectedForRoute);
            if (selectedPlacesForRoute.length > 1) {
                generateRouteBtn.disabled = false;
            } else {
                generateRouteBtn.disabled = true;
                routeLinkContainer.innerHTML = '';
            }
        }

        generateRouteBtn.addEventListener('click', () => {
            const placesForRoute = selectedRouteOrder
                .map(id => placesData.find(p => p.id === id))
                .filter(p => p && p.selectedForRoute); 

            if (placesForRoute.length < 2) {
                routeLinkContainer.innerHTML = '<p class="text-red-500">Rota oluşturmak için en az 2 yer seçmelisiniz.</p>';
                return;
            }
            const waypoints = placesForRoute.map(p => encodeURIComponent(p.mapQuery)).join('/');
            const mapsUrl = `https://www.google.com/maps/dir/${waypoints}`;

            routeLinkContainer.innerHTML = `
                <p class="font-semibold">Oluşturulan Rota Bağlantısı:</p>
                <a href="${mapsUrl}" target="_blank" class="text-sky-600 hover:text-sky-800 underline break-all">${mapsUrl}</a>
                <p class="text-xs text-gray-500 mt-1">Bu bağlantı, seçtiğiniz yerleri Google Haritalar'da açar. Rota optimizasyonu (en kısa yol vb.) Google Haritalar tarafından yapılır.</p>
            `;
        });

        addPlaceBtn.addEventListener('click', async () => {
            if (!userId || !placesCollectionRef) {
                addPlaceMessage.textContent = 'Veritabanı bağlantısı bekleniyor. Lütfen biraz bekleyin.';
                addPlaceMessage.className = 'text-sm mt-2 text-red-500';
                return;
            }
            const placeName = newPlaceNameInput.value.trim();
            if (!placeName) {
                addPlaceMessage.textContent = 'Lütfen bir yer adı girin.';
                addPlaceMessage.className = 'text-sm mt-2 text-red-500';
                return;
            }

            const existingPlace = placesData.find(p => p.name.toLowerCase() === placeName.toLowerCase());
            if (existingPlace) {
                addPlaceMessage.textContent = `'${placeName}' zaten listenizde mevcut.`;
                addPlaceMessage.className = 'text-sm mt-2 text-orange-500';
                return;
            }

            addPlaceBtnText.classList.add('hidden');
            addPlaceLoader.classList.remove('hidden');
            addPlaceMessage.textContent = 'Yer bilgileri (Gemini API) alınıyor...';
            addPlaceMessage.className = 'text-sm mt-2 text-blue-500';
            
            let newPlaceData = {
                name: placeName,
                country: "Bilinmiyor", city: "",
                description: "Açıklama otomatik olarak alınamadı.", category: "Bilinmiyor",
                visited: false, mapQuery: placeName, selectedForRoute: false,
                addedBy: "user", 
                createdAt: new Date().toISOString() 
            };

            try { 
                const prompt = `'${placeName}' adlı turistik yer hakkında aşağıdaki bilgileri JSON formatında ver: "country" (STRING, Türkçe ülke adı), "city" (STRING, Türkçe şehir adı, eğer varsa), "description" (STRING, Türkçe kısa ve çekici turistik açıklama, 1-2 cümle), "category" (STRING, Türkçe turistik kategori, örneğin 'Tarihi Yapı', 'Doğa Harikası', 'Müze'), "mapQuery" (STRING, Google Haritalar için etkili arama sorgusu). Eğer yer bulunamazsa veya bilgiler eksikse, "error" alanında bir mesaj içeren bir JSON döndür. Sadece JSON çıktısı ver.`;
                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory, generationConfig: { responseMimeType: "application/json" } };
                // API Anahtarı: Canvas dışı ortamda, bunu güvenli bir şekilde yönetmeniz gerekir (örn: backend proxy veya environment variable).
                // Bu örnekte, doğrudan frontend'de olması güvenlik riski taşır ancak hobi projesi için basitleştirilmiştir.
                // Gerçek bir uygulamada BU ŞEKİLDE KULLANMAYIN.
                const geminiApiKey = firebaseConfig.apiKey; // GEÇİCİ: Firebase API anahtarını kullanıyoruz, ama Gemini için ayrı anahtar gerekebilir.
                                                           // Normalde Gemini API anahtarınızı buraya girmeniz gerekir.
                                                           // Eğer Firebase API anahtarı Gemini için çalışmıyorsa, Gemini API'yi devre dışı bırakmanız veya
                                                           // doğru anahtarı sağlamanız gerekir. Bu kodda, hata durumunda Nominatim'e düşecek.

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${geminiApiKey}`;
                
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

                if (!response.ok) throw new Error(`Gemini API hatası: ${response.status}`);
                const result = await response.json();

                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                    const placeDetails = JSON.parse(result.candidates[0].content.parts[0].text);
                    if (placeDetails.error) throw new Error(placeDetails.error);
                    if (!placeDetails.country || !placeDetails.description || !placeDetails.category || !placeDetails.mapQuery) {
                         throw new Error('Gemini API eksik bilgi döndürdü.');
                    }
                    newPlaceData = { ...newPlaceData, ...placeDetails }; 
                    addPlaceMessage.textContent = `'${placeName}' (Gemini ile) bilgileri alındı.`;
                    addPlaceMessage.className = 'text-sm mt-2 text-green-600';
                } else {
                    throw new Error('Gemini API yanıtı anlaşılamadı.');
                }
            } catch (geminiError) {
                console.warn("Gemini API hatası:", geminiError.message);
                addPlaceMessage.textContent = `Gemini API ile bilgi alınamadı (${geminiError.message}). Nominatim (alternatif servis) deneniyor...`;
                addPlaceMessage.className = 'text-sm mt-2 text-orange-500';

                try { 
                    const nominatimUrl = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(placeName)}&format=json&addressdetails=1&accept-language=tr,en&limit=1`;
                    const nominatimResponse = await fetch(nominatimUrl, { headers: { 'User-Agent': 'AvrupaGeziListesiApp/1.0' } }); 
                    if (!nominatimResponse.ok) throw new Error(`Nominatim API hatası: ${nominatimResponse.status}`);
                    const nominatimData = await nominatimResponse.json();

                    if (nominatimData && nominatimData.length > 0) {
                        const Nplace = nominatimData[0];
                        newPlaceData.country = Nplace.address?.country || newPlaceData.country;
                        newPlaceData.city = Nplace.address?.city || Nplace.address?.town || Nplace.address?.village || Nplace.address?.county || newPlaceData.city;
                        newPlaceData.mapQuery = Nplace.display_name || `${placeName}, ${newPlaceData.country}`;
                        newPlaceData.description = `Nominatim ile bulundu: ${Nplace.display_name}. Detaylı açıklama ve kategori manuel eklenebilir.`;
                        newPlaceData.category = "Coğrafi Bilgi"; // Daha uygun bir kategori
                        addPlaceMessage.textContent = `'${placeName}' (Nominatim ile kısmi bilgiyle) eklendi.`;
                        addPlaceMessage.className = 'text-sm mt-2 text-blue-500';
                    } else {
                        addPlaceMessage.textContent = `Otomatik bilgi alma başarısız oldu. '${placeName}' temel bilgilerle eklenecek.`;
                        addPlaceMessage.className = 'text-sm mt-2 text-orange-600';
                    }
                } catch (fallbackError) {
                    console.warn("Fallback API (Nominatim) hatası:", fallbackError.message);
                    addPlaceMessage.textContent = `Otomatik bilgi alma tamamen başarısız oldu. '${placeName}' temel bilgilerle eklenecek.`;
                    addPlaceMessage.className = 'text-sm mt-2 text-red-600';
                }
            } finally {
                try {
                    const docRefWithAutoId = doc(placesCollectionRef); // Yeni boş döküman referansı al
                    newPlaceData.id = docRefWithAutoId.id; // Kendi ID'sini de ekleyelim
                    await setDoc(docRefWithAutoId, newPlaceData); // Firestore'a setDoc ile ekle
                    newPlaceNameInput.value = '';
                     // Başarı mesajı onSnapshot tarafından liste güncellendiğinde dolaylı olarak verilecek.
                     // İsterseniz buraya da bir mesaj ekleyebilirsiniz:
                     // addPlaceMessage.textContent = `'${newPlaceData.name}' listeye eklendi ve kaydedildi.`;
                     // addPlaceMessage.className = 'text-sm mt-2 text-green-700';
                } catch (dbError) {
                    console.error("Firestore'a ekleme hatası:", dbError);
                    addPlaceMessage.textContent = `Veritabanına kaydetme hatası: ${dbError.message}`;
                    addPlaceMessage.className = 'text-sm mt-2 text-red-700';
                }
                addPlaceBtnText.classList.remove('hidden');
                addPlaceLoader.classList.add('hidden');
            }
        });

        filterElement.addEventListener('change', () => {
            // Filtre değiştiğinde renderPlacesList onSnapshot tarafından tetiklenmeyeceği için manuel çağırıyoruz
            // Ancak onSnapshot zaten tüm veri değişikliklerini yakaladığı için bu gereksiz olabilir.
            // renderPlacesList(); // Aslında bu gerekmeyebilir, onSnapshot datayı güncelleyince UI da güncellenir.
        });
        
        initializeFirebase();

        window.addEventListener('beforeunload', () => {
            if (unsubscribePlaces) {
                unsubscribePlaces();
            }
        });

    </script>
</body>
</html>
